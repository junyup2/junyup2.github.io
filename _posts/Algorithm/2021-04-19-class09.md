---
title: "[Programmers] Linked Lists (3)"
categories:
  - Data Structure
tags:
  - programmers
  - algorithm
  - data structure
  - linked lists
toc: true
toc_sticky: true
toc_label: "ì—°ê²° ë¦¬ìŠ¤íŠ¸"
toc_icon: "linked lists"
---

ğŸ“Œ **ìë£Œêµ¬ì¡°** & **ì•Œê³ ë¦¬ì¦˜**<br>
{: .notice--primary}

# 09 ê°• : ì—°ê²° ë¦¬ìŠ¤íŠ¸(Linked Lists) - (3)
---

## ì—°ê²° ë¦¬ìŠ¤íŠ¸ê°€ í˜ì„ ë°œíœ˜ í•  ë•Œ
  - ì—°ê²° ë¦¬ìŠ¤íŠ¸ëŠ” **<u>ì‚½ì…ê³¼ ì‚­ì œê°€ ìœ ì—°í•˜ë‹¤ëŠ” ê²ƒ</u>**ì´ ê°€ì¥ í° ì¥ì 
  - insertAt()ê³¼ popAt()ì´ íŠ¹ì • ë²ˆì§¸ ì›ì†Œë¼ëŠ” ìœ„ì¹˜ë¥¼ **í¬ì§€ì…˜(ìˆ˜)ë¡œ ì•Œë ¤ ì£¼ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ì–´ë–¤ ë…¸ë“œë¥¼ ì£¼ê³  ê·¸ ë’¤ì— ì—°ì‚°ì„ ì‹¤í–‰**í•˜ëŠ” ì¡°ê¸ˆ í™•ì¥Â·ë³€í˜•ëœ ì—°ê²° ë¦¬ìŠ¤íŠ¸

  - ì´ì „ì— **headì˜ ì¸ë±ìŠ¤ë¥¼ 0ì´ ì•„ë‹Œ 1ë¡œ ì‹œì‘í•œ ì´ìœ **ê°€ ì—¬ê¸°ì— ìˆìŒ
    - ë§¨ì•ì— **ë”ë¯¸ ë…¸ë“œ(dummy node)**ë¼ê³  ë¶ˆë¦¬ëŠ”, <u>ë°ì´í„° ì›ì†Œë¥¼ ë‹´ê³  ìˆì§€ ì•Šê³  ìë¦¬ë§Œ ì°¨ì§€í•˜ê³  ìˆëŠ” ë…¸ë“œ</u>ë¥¼ ì¶”ê°€í•œ ë¦¬ìŠ¤íŠ¸ë¡œì„œ êµ¬í˜„
    - íŠ¹ì • ë…¸ë“œ ë’¤ì— ì—°ì‚°ì„ í•˜ê¸° ë•Œë¬¸ì— ë§¨ì•ì˜ ì›ì†Œë¥¼ ì‚½ì…/ì‚­ì œ í•˜ê¸°ìœ„í•´ ë”ë¯¸ ë…¸ë“œê°€ í•„ìš”

```ì¼ë°˜ì ì¸ ì—°ê²°ë¦¬ìŠ¤íŠ¸```
```python
class LinkedList:
      def __init__(self):
        self.nodeCount = 0
        self.head = None
        self.tail = None
```

```í™•ì¥Â·ë³€í˜•ëœ ì—°ê²°ë¦¬ìŠ¤íŠ¸```
```python
# ë§¨ ì•ì— dummy nodeë¥¼ ì¶”ê°€í•œ í˜•íƒœ
class LinkedList:
      def __init__(self):
        self.nodeCount = 0
        self.head = Node(None)
        self.tail = None
        self.head.next = self.tail
```

### ë¦¬ìŠ¤íŠ¸ì˜ ìˆœíšŒ
- ë‹¤ìŒìœ¼ë¡œ ì´ë™í•˜ë©´ì„œ ë°ì´í„°ë¥¼ ì–»ì–´ëƒ„

  ```ê¸°ì¡´ì˜ ë¦¬ìŠ¤íŠ¸ ìˆœíšŒ```
  ```python
  def traverse(self):
    answer = []
    curr = self.head
    while curr != None:
    answer.append(curr.data)
    curr = curr.next
    eturn answer
  ```

  ```í™•ì¥Â·ë³€í˜•ëœ ë¦¬ìŠ¤íŠ¸ ìˆœíšŒ```
  ```python
  def traverse(self):
    result = []
    curr = self.head
    # whileì˜ ì¡°ê±´ì´ ë°”ë€œ
    while curr.next:
      curr = curr.next
      result.append(curr.data)
    return result
  ```
### kë²ˆì§¸ ì›ì†Œ ì–»ì–´ë‚´ê¸°

- pos < 1 -> pos < 0ìœ¼ë¡œ í•´ì„œ getAt(0)ì„ headë¡œ i = 0ë¶€í„° ì‹œì‘
  - i = 1 ë¡œ ì‹œì‘í–ˆë˜ ë¶€ë¶„ì„ 0ìœ¼ë¡œ ì´ˆê¸°í™” í•´ì„œ headë¥¼ ê°€ë¦¬í‚´

  ```ê¸°ì¡´ì˜ getAt()```
```python
def getAt(self, pos):
    if pos < 1 or pos > self.nodeCount:
      return None

      i = 1
      curr = self.head
      while i < pos:
        curr = curr.next
        i += 1
      return curr
```
  ```í™•ì¥Â·ë³€í˜•ëœ ë¦¬ìŠ¤íŠ¸ì˜ getAt()```
```python
def getAt(self, pos):
    if pos < 0 or pos > self.nodeCount:
      return None

      i = 0
      curr = self.head
      while i < pos:
        curr = curr.next
          i += 1
      return curr
```

### ì›ì†Œì˜ ì‚½ì…
- **prevê°€ ê°€ë¦¬í‚¤ëŠ” nodeì˜ ë‹¤ìŒì— newNodeë¥¼ ì‚½ì…í•˜ê³ , ì„±ê³µ/ì‹¤íŒ¨ì— ë”°ë¼ True/Falseë¥¼ return**
- ë§¨ ëì— ì¶”ê°€í•˜ëŠ” ê²½ìš°ë¥¼ ê³ ë ¤(pos == nodeCount + 1)
- dummy nodeë¥¼ ë§¨ ì•ì— ì¶”ê°€í•¨ìœ¼ë¡œì¨ ì½”ë“œê°€ ì´ì „ë³´ë‹¤ ê¹”ë”í•˜ê³  ê°„ê²°í•´ì§

```python
def insertAfter(self, prev, newNode):
    newNode.next = prev.next
    if prev.next is None:
      self.tail = newNode
      prev.next = newNode
      self.nodeCount += 1
  return True
```
- insertAt()ì˜ êµ¬í˜„
  - ì´ë¯¸ êµ¬í˜„í•œ insertAfter()ë¥¼ í˜¸ì¶œí•˜ì—¬ êµ¬í˜„
    1. pos ë²”ìœ„ ì¡°ê±´ í™•ì¸
    2. pos == 1ì¸ ê²½ìš°, head ë’¤ì— newNodeë¥¼ ì‚½ì…
    3. pos == nodeCount + 1 ì¸ ê²½ìš°, prev <- tail
    4. ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš°, prev <- getAt(...)

  ```python
    def insertAt(self, pos, newNode):
      if pos < 1 or pos > self.nodeCount + 1:
        return False

      if pos != 1 and pos == self.nodeCount + 1:
        prev = self.tail
      else:
        prev = self.getAt(pos - 1)

      return self.insertAfter(prev, newNode)
    ```

### ì›ì†Œì˜ ì‚­ì œ

- **prevì˜ ë‹¤ìŒ nodeë¥¼ ì‚­ì œí•˜ê³  ê·¸ nodeì˜ dataë¥¼ return**
- prevê°€ ë§ˆì§€ë§‰ nodeì¸ ê²½ìš°(prev.next == None)
  - ì‚­ì œí•  nodeê°€ ì—†ìŒ
  - return None
- ë¦¬ìŠ¤íŠ¸ ë§¨ ëì˜ nodeë¥¼ ì‚­ì œ(curr.next == None)
  - Tail ì¡°ì • í•„ìš”

```python
def popAfter(self, prev):
  if prev.next is None:
    return None

  curr = prev.next

  if curr.next is None:
    self.tail = prev
    prev.next = curr.next
    self.nodeCount -= 1

    return curr.data
```
- popAt()ì˜ êµ¬í˜„
```python
def popAt(self, pos):
    if pos < 1 or pos > self.nodeCount:
      raise IndexError

    if pos == 1 and pos == self.nodeCount + 1:
      prev = self.head
    else:
      prev = self.getAt(pos - 1)

    return self.popAfter(prev)
```

### ë‘ ì—°ê²°ë¦¬ìŠ¤íŠ¸ì˜ ì—°ê²°
- Dummy nodeê°€ ìˆìŒì„ ì¸ì§€

  ```ê¸°ì¡´ì˜ ë¦¬ìŠ¤íŠ¸ì˜ ì—°ê²°```
```python
def concat(self, L):
  self.tail.next = L.head
  if L.tail:
    self.tail = L.tail
  self.nodeCount += L.nodeCount
```
```í™•ì¥Â·ë³€í˜•ëœ ë¦¬ìŠ¤íŠ¸ì˜ ì—°ê²°```
```python
def concat(self, L):
  self.tail.next = L.head.next
  if L.tail:
    self.tail = L.tail
  self.nodeCount += L.nodeCount
```


---



ğŸ”” **í¬ìŠ¤íŒ… ê³µì§€** <br><br>
ë³¸ í¬ìŠ¤íŒ…ì€ **ìë£Œêµ¬ì¡° & ì•Œê³ ë¦¬ì¦˜**ê³¼ ê´€ë ¨ëœ ë‚´ìš©ìœ¼ë¡œ,<br>
í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ì˜ ã€Œ ì–´ì„œì™€! ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ì€ ì²˜ìŒì´ì§€? ã€ ê°•ì˜ë¥¼ ìˆ˜ê°•í•˜ê³  ì‘ì„±<br>
ì¶œì²˜ - [ì–´ì„œì™€! ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ì€ ì²˜ìŒì´ì§€? | í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ (programmers.co.kr)](https://programmers.co.kr/learn/courses/57)<br>
{: .notice--success}