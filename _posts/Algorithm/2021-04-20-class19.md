---
title: "[Programmers] Binary Trees - BFS"
categories:
  - Data Structure
tags:
  - programmers
  - algorithm
  - data structure
  - trees
toc: true
toc_sticky: true
toc_label: "ì´ì§„ íŠ¸ë¦¬ - ë„“ì´ ìš°ì„  ìˆœíšŒ"
toc_icon: "binary trees"
---

ğŸ“Œ **ìë£Œêµ¬ì¡°** & **ì•Œê³ ë¦¬ì¦˜**<br>
{: .notice--primary}

# 19ê°• : ì´ì§„ íŠ¸ë¦¬(Binary Trees) - ë„“ì´ ìš°ì„  ìˆœíšŒ(BFS, Breadth First Traversal)
---
## ë„“ì´ ìš°ì„  ìˆœíšŒ
- ìˆ˜ì¤€(level)ì´ ë‚®ì€ ë…¸ë“œë¥¼ ìš°ì„ ìœ¼ë¡œ ë°©ë¬¸
- ê°™ì€ ìˆ˜ì¤€ì˜ ë…¸ë“œë“¤ ì‚¬ì´ì—ëŠ”
  - ë¶€ëª¨ ë…¸ë“œì˜ ë°©ë¬¸ ìˆœì„œì— ë”°ë¼ ë°©ë¬¸
  - ì™¼ìª½ ìì‹ ë…¸ë“œë¥¼ ì˜¤ë¥¸ìª½ ìì‹  ë³´ë‹¤ ë¨¼ì € ë°©ë¬¸
- **ì¬ê·€ì  ë°©ë²•ì´ ì í•©í•˜ì§€ ì•ŠìŒ**  
![bfs](https://user-images.githubusercontent.com/76204590/136343936-472b5d1d-0c27-4978-99bb-20244f6a7e39.png)

- í•œ ë…¸ë“œë¥¼ ë°©ë¬¸í–ˆì„ ë•Œ, **ë‚˜ì¤‘ì— ë°©ë¬¸í•  ë…¸ë“œë“¤ì„ ìˆœì„œëŒ€ë¡œ ê¸°ë¡**í•´ ë‘ì–´ì•¼ í•¨
  - í(queue)ë¥¼ ì´ìš©

### ë„“ì´ ìš°ì„  ìˆœíšŒ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
1. (ì´ˆê¸°í™”)Traversal <- ë¹ˆ ë¦¬ìŠ¤íŠ¸,  q <- ë¹ˆ í
2. ë¹ˆ íŠ¸ë¦¬ê°€ ì•„ë‹ˆë©´ root nodeë¥¼ q ì— ì¶”ê°€(enqueue)
3. qê°€ ë¹„ì–´ìˆì§€ ì•Šì€ ë™ì•ˆ
  - node <- qì—ì„œ ì›ì†Œë¥¼ ì¶”ì¶œ(dequeue)
  - node ë°©ë¬¸(Traversalì— nodeì˜ ê°’(data)ë¥¼ append)
  - nodeì˜ ì™¼ìª½ -> ì˜¤ë¥¸ìª½ ìì‹(ìˆìœ¼ë©´)ë“¤ì„ qì— ì¶”ê°€
4. qê°€ ë¹ˆ íê°€ ë˜ë©´ ëª¨ë“  ë…¸ë“œ ë°©ë¬¸ ì™„ë£Œ  

```ìˆœíšŒì˜ êµ¬í˜„(bfs)```
```python
class ArrayQueue:

    def __init__(self):
        self.data = []

    def size(self):
        return len(self.data)

    def isEmpty(self):
        return self.size() == 0

    def enqueue(self, item):
        self.data.append(item)

    def dequeue(self):
        return self.data.pop(0)

    def peek(self):
        return self.data[0]

class Node:

    def __init__(self, item):
        self.data = item
        self.left = None
        self.right = None


class BinaryTree:

    def __init__(self, r):
        self.root = r


    def bft(self):
        traversal = []
        q = ArrayQueue()

        if self.root:
            q.enqueue(self.root)

        while q.size() != 0:
            element = q.dequeue()
            traversal.append(element.data)
            if element.left:
                q.enqueue(element.left)
            if element.right:
                q.enqueue(element.right)

        return traversal


def solution(x):
    return 0
```
---



ğŸ”” **í¬ìŠ¤íŒ… ê³µì§€** <br><br>
ë³¸ í¬ìŠ¤íŒ…ì€ **ìë£Œêµ¬ì¡° & ì•Œê³ ë¦¬ì¦˜**ê³¼ ê´€ë ¨ëœ ë‚´ìš©ìœ¼ë¡œ,<br>
í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ì˜ ã€Œ ì–´ì„œì™€! ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ì€ ì²˜ìŒì´ì§€? ã€ ê°•ì˜ë¥¼ ìˆ˜ê°•í•˜ê³  ì‘ì„±<br>
ì¶œì²˜ - [ì–´ì„œì™€! ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ì€ ì²˜ìŒì´ì§€? | í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ (programmers.co.kr)](https://programmers.co.kr/learn/courses/57)<br>
{: .notice--success}