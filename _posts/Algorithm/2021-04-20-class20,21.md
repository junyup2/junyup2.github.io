---
title: "[Programmers] Binary Search Trees"
categories:
  - Data Structure
tags:
  - programmers
  - algorithm
  - data structure
  - trees
toc: true
toc_sticky: true
toc_label: "ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬"
toc_icon: "binary search trees"
---

ğŸ“Œ **ìë£Œêµ¬ì¡°** & **ì•Œê³ ë¦¬ì¦˜**<br>
{: .notice--primary}

# 20, 21ê°• : ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(Binary Search Trees)
---

## ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬
- ëª¨ë“  ë…¸ë“œì— ëŒ€í•´ì„œ ë‹¤ìŒì˜ ì„±ì§ˆì„ ë§Œì¡±í•˜ëŠ” ì´ì§„ íŠ¸ë¦¬
  - **ì™¼ìª½** ì„œë¸ŒíŠ¸ë¦¬ì— ìˆëŠ” ë°ì´í„°ëŠ” ëª¨ë‘ í˜„ì¬ ë…¸ë“œì˜ ê°’ë³´ë‹¤ **ì‘ìŒ**
  - **ì˜¤ë¥¸ìª½** ì„œë¸ŒíŠ¸ë¦¬ì— ìˆëŠ” ë°ì´í„°ëŠ” ëª¨ë‘ í˜„ì¬ ë…¸ë“œì˜ ê°’ë³´ë‹¤ **í¼**
  - (ë‹¨, ì¤‘ë³µë˜ëŠ” ë°ì´í„° ì›ì†ŒëŠ” ì—†ëŠ” ê²ƒìœ¼ë¡œ ê°€ì •)


- íƒìƒ‰ì„ í• ë•Œ ë£¨íŠ¸ ë…¸ë“œì—ì„œ ì‹œì‘í•´ í•œ ë²ˆì— í•œ ë‹¨ê³„ì”© ê°„ì„ ì„ ë”°ë¼ ì•„ë˜ë¡œ ë‚´ë ¤ê°
- ì–´ëŠ ë…¸ë“œë¥¼ ë°©ë¬¸ í–ˆì„ ë•Œ, ì´ ë…¸ë“œì— ë‹´ê¸´ ë°ì´í„° ìœˆì†Œë³´ë‹¤ ì°¾ê³ ì í•˜ëŠ” í‚¤ê°€
  - ë” ì‘ì€ ê²½ìš°ì—ëŠ” ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬
  - ë” í°ê²½ìš°ì—ëŠ” ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ íƒí•¨
- (ë°˜ëŒ€ìª½ ì„œë¸ŒíŠ¸ë¦¬ì—ëŠ” ì°¾ê³ ìí•˜ëŠ” ê°’ì´ ì—†ìŒì„ ë³´ì¥í•  ìˆ˜ ìˆìœ¼ë‹ˆê¹Œ, íƒìƒ‰í•  í•„ìš”ê°€ ì—†ë‹¤ëŠ” ì„±ì§ˆì„ ì´ìš©)

### (ì •ë ¬ëœ) ë°°ì—´ì„ ì´ìš©í•œ ì´ì§„ íƒìƒ‰ê³¼ ë¹„êµ
- ì¥ì 
  - ë°ì´í„° ì›ì†Œì˜ ì¶”ê°€Â·ì‚­ì œê°€ ìš©ì´
- ë‹¨ì 
  - ê³µê°„ ìš”ì†Œê°€ í¼(ìì‹ì˜ ì™¼ìª½Â·ì˜¤ë¥¸ìª½ì„ ê¸°ë¡í•´ë†”ì•¼í•˜ê¸° ë•Œë¬¸)
  - í•­ìƒ O(log n)ì˜ íƒìƒ‰ ë³µì¡ë„ë¥¼ ê°–ì§€ëŠ” ëª»í•¨

### ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ì¶”ìƒì  ìë£Œ êµ¬ì¡°
- ë°ì´í„° í‘œí˜„
  - ê° ë…¸ë“œëŠ” key, valueì˜ ìŒìœ¼ë¡œ í‘œí˜„
  - keyë¥¼ ì´ìš©í•˜ì—¬ ê²€ìƒ‰ ê°€ëŠ¥(ë³´ë‹¤ ë³µì¡í•œ ë°ì´í„° ë ˆì½”ë“œë¡œ í™•ì¥ ê°€ëŠ¥)


- ì—°ì‚°ì˜ ì •ì˜
  - insert(key, data) : íŠ¸ë¦¬ì— ì£¼ì–´ì§„ ë°ì´í„° ì›ì†Œë¥¼ ì¶”ê°€
  - **remove(key)** : íŠ¹ì • ì›ì†Œë¥¼ íŠ¸ë¦¬ë¡œë¶€í„° ì‚­ì œ
  - **lookup(key)** : íŠ¹ì • ì›ì†Œë¥¼ ê²€ìƒ‰
    - ì°¾ì€ ë…¸ë“œì™€, ê·¸ê²ƒì˜ <u>ë¶€ëª¨ë…¸ë“œ(removeì‹œ í•„ìš”</u>), ê°ê° ì—†ìœ¼ë©´ Noneì„ return
  - inorder() : í‚¤ì˜ ìˆœì„œëŒ€ë¡œ ë°ì´í„° ì›ì†Œë¥¼ ë‚˜ì—´
  - min(), max() : ìµœì†ŒÂ·ìµœëŒ€í‚¤ë¥¼ ê°€ì§€ëŠ” ì›ì†Œë¥¼ ê°ê° íƒìƒ‰

#### ì‚½ì… insert() ì—°ì‚° êµ¬ì¡°
  ```ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ì‚½ì… ì—°ì‚° êµ¬í˜„```
  ```python
  class Node:
    def __init__(self, key, data):
        self.key = key
        self.data = data
        self.left = None
        self.right = None

    def inorder(self):
        traversal = []
        if self.left:
            traversal += self.left.inorder()
        traversal.append(self)
        if self.right:
            traversal += self.right.inorder()
        return traveral

    def min(self):
        # ê³„ì†í•´ì„œ ì™¼ìª½ì„ ì°¾ìœ¼ë©´ min
        if self.left:
            return self.left.min()
        else:
            return self

    def max(self):
        if self.right:
            return self.right.max()
        else:
            return self

    def lookup(self, key, parent=None):
        if key < self.key:
            if self.left:
                return self.left.lookup(key, self)
            else:
                return None, None
        elif key > self.key:
            if self.right:
                return self.right.lookup(key, self)
            else:
                return None, None
        else:
            # self = ì°¾ì•„ì§„ node
            return self, parent

    def insert(self, key, data):
        if key > self.key:
            if self.right:
                self.right.insert(key, data)
            else:
                self.root = Node(key, data)
                self.right = self.root
        elif key < self.key:
            if self.left:
                self.left.insert(key, data)
            else:
                self.root = Node(key, data)
                self.left = self.root
        else:
            raise KeyError


    class BinSearchTree:
        # ë¹ˆ íŠ¸ë¦¬ë¡œ ì´ˆê¸°í™”
        def __init__(self):
            self.root = None

        def inorder(self):
            if self.root:
                return self.root.inorder()
            else:
                return []

        def min(self):
            if self.root:
                # rootì—ì„œë¶€í„° minì„ ì°¾ìŒ
                return self.root.min()
            else:
                return None

        def max(self):
            if self.root:
                return self.root.max()
            else:
                return None

        def lookup(self, key):
            if self.root:
                return self.root.lookup(key)
            else:
                return None, None

        def insert(self, key, data):
            if self.root:
                self.root.insert(key, data)
            else:
                self.root = Node(key, data)
```


#### ì‚­ì œ remove() ì—°ì‚°
- í‚¤(key)ë¥¼ ì´ìš©í•´ì„œ ë…¸ë“œë¥¼ ì°¾ìŒ
    - í•´ë‹¹ í‚¤ì˜ ë…¸ë“œê°€ ì—†ìœ¼ë©´, ì‚­ì œí•  ê²ƒë„ ì—†ìŒ
    - <u>ì°¾ì€ ë…¸ë“œì˜ **ë¶€ëª¨ë…¸ë“œ**ë„ ì•Œê³  ìˆì–´ì•¼ í•¨</u>
  - <u>ì°¾ì€ ë…¸ë“œë¥¼ ì œê±°í•˜ê³ ë„ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ì„±ì§ˆì„ ë§Œì¡±í•˜ë„ë¡</u> íŠ¸ë¦¬ì˜ êµ¬ì¡°ë¥¼ ì •ë¦¬


- ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„
  - ì…ë ¥ : í‚¤(key)
  - ì¶œë ¥
    - ì‚­ì œí•œ ê²½ìš° True
    - í•´ë‹¹ í‚¤ì˜ ë…¸ë“œê°€ ì—†ëŠ” ê²½ìš° False

#### ì‚­ì œë˜ëŠ” ë…¸ë“œì— ë”°ë¥¸ êµ¬ì¡°ì˜ ìœ ì§€
  - ë§ë‹¨(leaf)ë…¸ë“œì˜ ì‚­ì œ
    - ê·¸ëƒ¥ ê·¸ ë…¸ë“œë¥¼ ì—†ì• ë©´ ë¨
      - ë§ë‹¨ ë…¸ë“œê°€ ë£¨íŠ¸ ë…¸ë“œì¸ ê²½ìš°, íŠ¸ë¦¬ ì „ì²´ê°€ ì—†ì–´ì§
    - ë¶€ëª¨ ë…¸ë“œì˜ ë§í¬ë¥¼ ì¡°ì •(ì¢Œ/ìš°)
  - ìì‹ì´ í•˜ë‚˜ì¸ ë…¸ë“œì˜ ì‚­ì œ
    - ì‚­ì œë˜ëŠ” ë…¸ë“œ ìë¦¬ì— ê·¸ ìì‹ì„ ëŒ€ì‹  ë°°ì¹˜
      - **ì‚­ì œë˜ëŠ” ë…¸ë“œê°€ ë£¨íŠ¸ ë…¸ë“œì¸ ê²½ìš°, ëŒ€ì‹  ë“¤ì–´ì˜¤ëŠ” ìì‹ì´ ìƒˆë¡œìš´ rootê°€ ë¨**
    - ìì‹ì´ ì™¼ìª½/ì˜¤ë¥¸ìª½
    - ë¶€ëª¨ ë…¸ë“œì˜ ë§í¬ë¥¼ ì¡°ì •(ì¢Œ/ìš°)
  - ìì‹ì´ ë‘˜ì¸ ë…¸ë“œì˜ ì‚­ì œ
    - **ì‚­ì œë˜ëŠ” ë…¸ë“œë³´ë‹¤ ë°”ë¡œ ë‹¤ìŒ(í°) í‚¤ë¥¼ ê°€ì§€ëŠ” ë…¸ë“œ**ë¥¼ ì°¾ì•„  
     ê·¸ ë…¸ë“œë¥¼ **ì‚­ì œë˜ëŠ” ë…¸ë“œ ìë¦¬ì— ëŒ€ì‹  ë°°ì¹˜**í•˜ê³  ì´ ë…¸ë“œë¥¼ ëŒ€ì‹  ì‚­ì œ

```ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ì‚­ì œ ì—°ì‚° êµ¬í˜„```
```python
class Node:

    def __init__(self, key, data):
        self.key = key
        self.data = data
        self.left = None
        self.right = None


    def insert(self, key, data):
        if key < self.key:
            if self.left:
                self.left.insert(key, data)
            else:
                self.left = Node(key, data)
        elif key > self.key:
            if self.right:
                self.right.insert(key, data)
            else:
                self.right = Node(key, data)
        else:
            raise KeyError('Key %s already exists.' % key)


    def lookup(self, key, parent=None):
        if key < self.key:
            if self.left:
                return self.left.lookup(key, self)
            else:
                return None, None
        elif key > self.key:
            if self.right:
                return self.right.lookup(key, self)
            else:
                return None, None
        else:
            return self, parent


    def inorder(self):
        traversal = []
        if self.left:
            traversal += self.left.inorder()
        traversal.append(self)
        if self.right:
            traversal += self.right.inorder()
        return traversal


    def countChildren(self):
        count = 0
        if self.left:
            count += 1
        if self.right:
            count += 1
        return count


class BinSearchTree:

    def __init__(self):
        self.root = None


    def insert(self, key, data):
        if self.root:
            self.root.insert(key, data)
        else:
            self.root = Node(key, data)


    def lookup(self, key):
        if self.root:
            return self.root.lookup(key)
        else:
            return None, None


    def remove(self, key):
        node, parent = self.lookup(key)
        if node:
            nChildren = node.countChildren()
            # The simplest case of no children
            if nChildren == 0:
                # ë§Œì•½ parent ê°€ ìˆë‹¤ë©´
                # node ê°€ ì™¼ìª½ ìì‹ì¸ì§€ ì˜¤ë¥¸ìª½ ìì‹ì¸ì§€ íŒë‹¨
                # parent.left ë˜ëŠ” parent.right ë¥¼ None ìœ¼ë¡œ í•˜ê³ 
                # leaf node ì˜€ë˜ ìì‹ì„ íŠ¸ë¦¬ì—ì„œ ëŠì–´ë‚´ì–´ ì—†ì•°
                if parent:
                    if node == parent.left:
                        parent.left = None
                    elif node == parent.right:
                        parent.right = None
                # ë§Œì•½ parent ê°€ ì—†ìœ¼ë©´ (í•´ë‹¹ node ê°€ root ì¸ ê²½ìš°)
                # self.root ë¥¼ None ìœ¼ë¡œ í•˜ì—¬ ë¹ˆ íŠ¸ë¦¬ë¡œ ë§Œë“¬
                else:
                    self.root = None
            # When the node has only one child
            elif nChildren == 1:
                # í•˜ë‚˜ ìˆëŠ” ìì‹ì´ ì™¼ìª½ì¸ì§€ ì˜¤ë¥¸ìª½ì¸ì§€ë¥¼ íŒë‹¨
                # ê·¸ ìì‹ì„ ì–´ë–¤ ë³€ìˆ˜ê°€ ê°€ë¦¬í‚¤ë„ë¡ í•¨
                if node.left:
                    temp = node.left
                else:
                    temp = node.right
                # ë§Œì•½ parent ê°€ ìˆë‹¤ë©´
                # node ê°€ ì™¼ìª½ ìì‹ì¸ì§€ ì˜¤ë¥¸ìª½ ìì‹ì¸ì§€ íŒë‹¨
                # ìœ„ì—ì„œ ê°€ë¦¬í‚¨ ìì‹ì„ ëŒ€ì‹  node ì˜ ìë¦¬ì— ë„£ìŒ
                if parent:
                    if parent.left == node:
                        parent.left = temp
                    else:
                        parent.right = temp

                # ë§Œì•½ parent ê°€ ì—†ìœ¼ë©´ (í•´ë‹¹ node ëŠ” root ì¸ ê²½ìš°)
                # self.root ì— ìœ„ì—ì„œ ê°€ë¦¬í‚¨ ìì‹ì„ ëŒ€ì‹  ë„£ìŒ
                else:
                    self.root = temp
            # When the node has both left and right children
            else:
                parent = node
                successor = node.right
                # parent ëŠ” node ë¥¼ ê°€ë¦¬í‚¤ê³  ìˆê³ ,
                # successor ëŠ” node ì˜ ì˜¤ë¥¸ìª½ ìì‹ì„ ê°€ë¦¬í‚¤ê³  ìˆìœ¼ë¯€ë¡œ
                # successor ë¡œë¶€í„° ì™¼ìª½ ìì‹ì˜ ë§í¬ë¥¼ ë°˜ë³µí•˜ì—¬ ë”°ë¼ê°ìœ¼ë¡œì¨
                # ìˆœí™˜ë¬¸ì´ ì¢…ë£Œí•  ë•Œ successor ëŠ” ë°”ë¡œ ë‹¤ìŒ í‚¤ë¥¼ ê°€ì§„ ë…¸ë“œë¥¼,
                # ê·¸ë¦¬ê³  parent ëŠ” ê·¸ ë…¸ë“œì˜ ë¶€ëª¨ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ë„ë¡ ì°¾ì•„ëƒ„
                while successor.left:
                    parent = successor
                    successor = successor.left
                # ì‚­ì œí•˜ë ¤ëŠ” ë…¸ë“œì¸ node ì— successor ì˜ key ì™€ data ë¥¼ ëŒ€ì…
                node.key = successor.key
                node.data = successor.data
                # ì´ì œ, successor ê°€ parent ì˜ ì™¼ìª½ ìì‹ì¸ì§€ ì˜¤ë¥¸ìª½ ìì‹ì¸ì§€ë¥¼ íŒë‹¨
                # ê·¸ì— ë”°ë¼ parent.left ë˜ëŠ” parent.right ë¥¼
                # successor ê°€ ê°€ì§€ê³  ìˆë˜ (ì—†ì„ ìˆ˜ë„ ìˆì§€ë§Œ) ìì‹ì„ ê°€ë¦¬í‚¤ë„ë¡ í•¨
                if parent.left == successor:
                    if successor.right:
                        parent.left = successor.right
                    else:
                        parent.left = None
                else:
                    parent.right = successor.right
                return True
        else:
            return False


    def inorder(self):
        if self.root:
            return self.root.inorder()
        else:
            return []


def solution(x):
    return 0
```

#### ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ê°€ ë³„ë¡œ íš¨ìœ¨ì ì´ì§€ ëª»í•œ ê²½ìš°
- í•œìª½ìœ¼ë¡œ ì¹˜ìš°ì³ì ¸, ê· í˜•ì´ ì¡íˆì§€ ì•Šì€ ê²½ìš°
- ë§ˆì§€ë§‰ì— ê°€ì„œ ë°œê²¬ë˜ê²Œ ë˜ëŠ” ê²½ìš°
  - ì„ í˜• íƒìƒ‰ê³¼ ë™ë“±í•œ ì •ë„ì˜ ë³µì¡ë„ë¥¼ ê°€ì§€ê²Œ ë¨
    - ë†’ì´ì˜ ê· í˜•ì„ ë§ì¶”ì§€ ëª»í•˜ê³  í•œìª½ìœ¼ë¡œ ì¹˜ìš°ì³ì ¸ ìˆê¸° ë•Œë¬¸
    - í•­ìƒ O(log n)ì˜ íƒìƒ‰ ë³µì¡ë„ë¥¼ ê°–ì§€ëŠ” ëª»í•œë‹¤ëŠ” ê²ƒ

#### ë³´ë‹¤ ë‚˜ëŠ” ì„±ëŠ¥ì„ ë³´ì´ëŠ” ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬
- ë†’ì´ì˜ ê· í˜•ì„ ìœ ì§€í•¨ìœ¼ë¡œì¨ O(log n)ì˜ íƒìƒ‰ ë³µì¡ë„ë¥¼ ë³´ì¥
  - ê·¸ ëŒ€ì‹  ì‚½ì…, ì‚­ì œ ì—°ì‚°ì´ ë³´ë‹¤ ë³µì¡
- [AVL trees](https://ko.wikipedia.org/wiki/AVL_íŠ¸ë¦¬)
- [Red-black trees](https://ko.wikipedia.org/wiki/ë ˆë“œ-ë¸”ë™_íŠ¸ë¦¬)

![O_Tree](https://user-images.githubusercontent.com/76204590/136344673-47ae44c2-af12-4934-b9d8-58ba5da0cb8f.png)

---



ğŸ”” **í¬ìŠ¤íŒ… ê³µì§€** <br><br>
ë³¸ í¬ìŠ¤íŒ…ì€ **ìë£Œêµ¬ì¡° & ì•Œê³ ë¦¬ì¦˜**ê³¼ ê´€ë ¨ëœ ë‚´ìš©ìœ¼ë¡œ,<br>
í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ì˜ ã€Œ ì–´ì„œì™€! ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ì€ ì²˜ìŒì´ì§€? ã€ ê°•ì˜ë¥¼ ìˆ˜ê°•í•˜ê³  ì‘ì„±<br>
ì¶œì²˜ - [ì–´ì„œì™€! ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ì€ ì²˜ìŒì´ì§€? | í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ (programmers.co.kr)](https://programmers.co.kr/learn/courses/57)<br>
{: .notice--success}